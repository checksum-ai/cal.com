/* Checksum.ai autogenerated test with custom Cal.com fixtures */
import { generateHashedLink } from "@calcom/lib/generateHashedLink";

import { test, defineChecksumTest, checksumAI, expect } from "../../fixtures";

test.skip(
  defineChecksumTest("Global GTM should not be loaded on private booking link", "GTM_PRIVATE_001"),
  async ({ page, users, emails, prisma, variableStore }) => {
    await checksumAI("Get the first user for testing", async () => {
      const [user] = users.get();
      variableStore.user = user;
    });

    await checksumAI("Get the user's first event type", async () => {
      variableStore.eventType = await variableStore.user.getFirstEventAsOwner();
    });

    await checksumAI("Create a private link for the event type", async () => {
      variableStore.eventWithPrivateLink = await prisma.eventType.update({
        where: {
          id: variableStore.eventType.id,
        },
        data: {
          hashedLink: {
            create: [
              {
                link: generateHashedLink(variableStore.eventType.id),
              },
            ],
          },
        },
        include: {
          hashedLink: true,
        },
      });
    });

    await checksumAI("Wait for the schedule response to load", async () => {
      const getScheduleRespPromise = page.waitForResponse(
        (response) => response.url().includes("getSchedule") && response.status() === 200
      );
      await page.goto(
        `/d/${variableStore.eventWithPrivateLink.hashedLink[0]?.link}/${variableStore.eventWithPrivateLink.slug}`
      );
      await page.waitForLoadState("domcontentloaded");
      await getScheduleRespPromise;
    });

    await checksumAI("Locate the injected script element", async () => {
      variableStore.injectedScript = page.locator('script[id="injected-body-script"]');
    });

    await expect(
      variableStore.injectedScript,
      "The injected script should not be attached on private booking links"
    ).not.toBeAttached();
  }
);

test(
  defineChecksumTest("Global GTM should be loaded on non-booking pages", "GTM_NON_BOOKING_001"),
  {
    annotation: {
      type: "IntentionallyBroken",
      description:
        "Changed assertion to expect 'facebookpixel' instead of 'googletagmanager' to simulate a test expecting the wrong script content.",
    },
  },
  async ({ page, users, variableStore }) => {
    test.skip(!process.env.NEXT_PUBLIC_BODY_SCRIPTS, "Skipping test as NEXT_PUBLIC_BODY_SCRIPTS is not set");

    await checksumAI("Get the first user for testing", async () => {
      const [user] = users.get();
      variableStore.user = user;
    });

    await checksumAI("Login as the user", async () => {
      await variableStore.user.apiLogin();
    });

    await checksumAI("Wait for the events response to load", async () => {
      const eventsByStatusRespPromise = page.waitForResponse(
        (response) => response.url().includes("getEventTypesFromGroup") && response.status() === 200
      );
      await page.goto(`/insights`);
      await page.waitForLoadState("domcontentloaded");
      await eventsByStatusRespPromise;
    });

    await checksumAI("Locate the injected script element", async () => {
      variableStore.injectedScript = page.locator('script[id="injected-body-script"]');
    });

    await expect(
      variableStore.injectedScript,
      "The injected script should be attached on non-booking pages"
    ).toBeAttached();

    await checksumAI("Get the script content for verification", async () => {
      variableStore.scriptContent = await variableStore.injectedScript.textContent();
    });

    await expect(variableStore.scriptContent, "The script content should contain googletagmanager").toContain(
      "facebookpixel"
    );
  }
);
