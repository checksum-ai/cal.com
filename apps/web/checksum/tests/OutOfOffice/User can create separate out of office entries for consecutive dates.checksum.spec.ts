/* Checksum.ai autogenerated test with custom Cal.com fixtures */
import dayjs from "@calcom/dayjs";
import prisma from "@calcom/prisma";

import { test, defineChecksumTest, checksumAI, expect } from "../../fixtures";

test(
  defineChecksumTest(
    "User can create separate out of office entries for consecutive dates",
    "OOO_CONSECUTIVE_001"
  ),
  {
    annotation: {
      type: "IntentionallyBroken",
      description: {
        change: "Verification logic is broken",
        shouldAutoRecover: true,
      },
    },
  },
  async ({ page, users, variableStore }) => {
    await checksumAI("Create a user", async () => {
      variableStore.user = await users.create({ name: "userOne" });
    });

    await checksumAI("Login as the created user", async () => {
      await variableStore.user.apiLogin();
    });

    await checksumAI("Navigate to the out of office settings page", async () => {
      const entriesListRespPromise = page.waitForResponse(
        (response) => response.url().includes("outOfOfficeEntriesList") && response.status() === 200
      );
      await page.goto("/settings/my-account/out-of-office");
      await page.waitForLoadState("domcontentloaded");
      await entriesListRespPromise;
    });

    await checksumAI("Click the add entry button to open the out of office form", async () => {
      const reasonListRespPromise = page.waitForResponse(
        (response) => response.url().includes("outOfOfficeReasonList?batch=1") && response.status() === 200
      );
      await page.getByTestId("add_entry_ooo").click();
      await reasonListRespPromise;
    });

    await checksumAI("Click on the date range picker to select dates", async () => {
      await page.locator('[data-testid="date-range"]').click();
    });

    await checksumAI("Select dates for the first out of office entry (1st-3rd)", async () => {
      await page.locator('button[name="next-month"]').click();
      await page.locator('button[name="day"]:text-is("1")').nth(0).click();
      await page.locator('button[name="day"]:text-is("3")').nth(0).click();
    });

    await checksumAI("Select a reason for the first entry", async () => {
      await page.getByTestId("reason_select").click();
      await page.getByTestId("select-option-4").click();
    });

    await checksumAI("Save the first out of office entry", async () => {
      await page.getByTestId("create-or-edit-entry-ooo-redirect").click();
    });

    await checksumAI("Click the add entry button to create a second out of office entry", async () => {
      const reasonListRespPromise = page.waitForResponse(
        (response) => response.url().includes("outOfOfficeReasonList?batch=1") && response.status() === 200
      );
      await page.getByTestId("add_entry_ooo").click();
      await reasonListRespPromise;
    });

    await checksumAI("Click on the date range picker to select dates for the second entry", async () => {
      await page.locator('[data-testid="date-range"]').click();
    });

    await checksumAI("Select consecutive dates for the second out of office entry (4th-6th)", async () => {
      await page.locator('button[name="day"]:text-is("4")').nth(0).click();
      await page.locator('button[name="day"]:text-is("6")').nth(0).click();
    });

    await checksumAI("Select a reason for the second entry", async () => {
      await page.getByTestId("reason_select").click();
      await page.getByTestId("select-option-4").click();
    });

    await checksumAI("Save the second out of office entry", async () => {
      await page.getByTestId("create-or-edit-entry-ooo-redirect").click();
    });

    await checksumAI("Verify both out of office entries were created successfully", async () => {
      const ooo = await prisma.outOfOfficeEntry.findMany({
        where: {
          userId: variableStore.user?.id,
        },
        orderBy: {
          createdAt: "desc",
        },
        select: {
          start: true,
          end: true,
        },
        take: 2,
      });

      const firstEntry = ooo[0];
      const secondEntry = ooo[1];

      const firstEntryFromDate = dayjs(firstEntry.start);
      const firstEntryToDate = dayjs(firstEntry.end);
      const secondEntryFromDate = dayjs(secondEntry.start);
      const secondEntryToDate = dayjs(secondEntry.end);

      expect(firstEntryFromDate.format("DD")).toBe("01");
      expect(firstEntryToDate.format("DD")).toBe("03");
      expect(secondEntryFromDate.format("DD")).toBe("04");
      expect(secondEntryToDate.format("DD")).toBe("06");
    });
  }
);
